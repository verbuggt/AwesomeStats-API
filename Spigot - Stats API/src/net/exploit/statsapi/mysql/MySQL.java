package net.exploit.statsapi.mysql;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.function.Consumer;

import org.bukkit.Bukkit;
import org.bukkit.plugin.Plugin;

import net.exploit.statsapi.main.StatsAPI;
import net.exploit.statsapi.manager.LoginInfoManager;

public class MySQL {

	private Connection connection;

	private ExecutorService executor;
	private Plugin plugin;

	private String database, hostname, username, password;
	private int port;

	public MySQL(Plugin owner) {
		executor = Executors.newCachedThreadPool();
		plugin = owner;

		loadLoginInfo();
		connect();
	}

	private void loadLoginInfo() {
		LoginInfoManager loginInfo = StatsAPI.getApi().loginInfo;
		this.database = loginInfo.getDatabase();
		this.hostname = loginInfo.getHostname();
		this.username = loginInfo.getUsername();
		this.password = loginInfo.getPassword();
		this.port = loginInfo.getPort();
	}

	private void connect() {
		try {
			Class.forName("com.mysql.jdbc.Driver");
			connection = DriverManager.getConnection("jdbc:mysql://" + this.hostname + ":" + this.port + "/" + this.database, this.username, this.password);
		} catch (SQLException | ClassNotFoundException e) {
			e.printStackTrace();
		}
	}

	public void disconnect() {
		try {
			if (isConnected())
				connection.close();
			connection = null;
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public boolean isConnected() {
		try {
			return this.connection != null && this.connection.isClosed();
		} catch (SQLException e) {
			return false;
		}
	}

	public void update(String query) {
		executor.execute(() -> {
			try {
				Statement statement = connection.createStatement();
				statement.executeUpdate(query);
				statement.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		});
	}

	public void updateSynchronously(String query) {
		try {
			Statement statement = connection.createStatement();
			statement.executeUpdate(query);
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public void query(String query, Consumer<ResultSet> consumer) {
		executor.execute(() -> {
			try {
				Statement st = connection.createStatement();
				ResultSet rs = st.executeQuery(query);
				Bukkit.getScheduler().runTask(plugin, () -> consumer.accept(rs));
			} catch (SQLException ex) {
				ex.printStackTrace();
			}
		});
	}

	public ResultSet query(String query) throws SQLException {
		Statement st = connection.createStatement();
		return st.executeQuery(query);
	}

	public HashMap<String, String> getTableColumns(String table) {
		try {
			ResultSet resultSet = connection.getMetaData().getColumns(this.database, null, table, "%");
			HashMap<String, String> cols = new HashMap<>();
			while (resultSet.next()) {
				cols.put(resultSet.getString(4), resultSet.getString(6));
			}
			return cols;
		} catch (SQLException e) {
			e.printStackTrace();
			return null;
		}
	}

	public boolean tableExist(String tableName) {
		boolean tExists = false;
		try (ResultSet rs = connection.getMetaData().getTables(null, null, tableName, null)) {
			while (rs.next()) {
				String tName = rs.getString("TABLE_NAME");
				if (tName != null && tName.equals(tableName)) {
					tExists = true;
					break;
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return tExists;
	}

}

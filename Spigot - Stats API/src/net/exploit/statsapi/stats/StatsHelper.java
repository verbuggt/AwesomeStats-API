package net.exploit.statsapi.stats;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.UUID;
import java.util.function.Consumer;

import org.bukkit.Bukkit;

import net.exploit.statsapi.main.StatsAPI;
import net.exploit.statsapi.mysql.MySQL;
import net.exploit.statsapi.util.NameUUIDUtil;

public class StatsHelper {

    public static StatsHelper statsHelper;

    private MySQL mysql;
    private String worktable;
    private HashMap<String, Value> values = new HashMap<>();

    public StatsHelper(String table, boolean autoPoints, Value... values) {
        StatsHelper.statsHelper = this;
        this.mysql = StatsAPI.getApi().getMySQL();
        this.worktable = table.toLowerCase();

        Bukkit.getPluginManager().registerEvents(new StatsLoginListener(this), StatsAPI.getApi());

        if (autoPoints) {
            Value[] tempValues = new Value[values.length + 1];
            System.arraycopy(values, 0, tempValues, 0, values.length);
            tempValues[values.length] = new Value("points", VT.INT);
            values = tempValues;
        }

        int l = values.length;
        boolean alter = mysql.tableExist(worktable);
        boolean execute = !alter;
        HashMap<String, String> columns_delete = alter ? mysql.getTableColumns(worktable) : null;
        StringBuilder query = new StringBuilder(alter ? "ALTER TABLE " + worktable + " " : "CREATE TABLE IF NOT EXISTS " + worktable + "(uuid VARCHAR(36), ");

        for (int i = 0; i < l; i++) {
            Value v = values[i];
            String valueName = v.getName();
            try {
                validateValue(v);
            } catch (Exception e) {
                e.printStackTrace();
                break;
            }
            this.values.put(valueName, v);
            if (alter)
                if (columns_delete != null)
                    if (!columns_delete.containsKey(valueName)) {
                        if (execute)
                            query.append(", ");
                        query.append("ADD ").append(valueName).append(" ").append(v.getSQLString());
                        execute = true;
                    } else {
                        if (!v.getDataTypeName().equals(columns_delete.get(v.getName()))) {
                            if (execute)
                                query.append(", ");
                            query.append("MODIFY ").append(v.getName()).append(" ").append(v.getSQLString());
                            execute = true;
                        }
                        columns_delete.remove(v.getName());
                    }
                else
                    ;
            else {
                query.append(valueName).append(" ").append(v.getSQLString());
                if (i < l - 1)
                    query.append(", ");
                else if (i == l - 1)
                    query.append(", FOREIGN KEY (uuid) REFERENCES users(uuid));");
            }
        }
        if (alter)
            if (columns_delete != null)
                if (columns_delete.size() != 0) {
                    for (String s : columns_delete.keySet()) {
                        if (!s.equals("uuid")) {
                            query.append(execute ? ", DROP " : "DROP ").append(s.trim());
                            execute = true;
                        }
                    }
                    query.append(";");
                }

        // Hello. Im a debug print
        // System.out.println("\nEXECUTE QUEREY: " + execute + "\nQUERY: \n" + query);
        if (execute)
            // TODO: BACKUP!!!
            mysql.updateSynchronously(query.toString());
    }

    public StatsHelper(String table, Value... values) {
        this(table, false, values);
    }

    public StatsHelper(String table, Value[] values, boolean autoPoints) {
        this(table, autoPoints, values);
    }

    private void validateValue(Value v) throws Exception {
        if (v.getName() == null || v.getName().isEmpty())
            throw new Exception("ValueName can not be empty");
        else if (this.values.containsKey(v.getName()))
            throw new Exception("Illegal Value Parameters: Duplicate Entry");
        else if (v.getName().equalsIgnoreCase("uuid"))
            throw new Exception("Illegal Value Parameters: Forbidden Valuename");
        else if (v.getName().equalsIgnoreCase("name") || v.getName().equalsIgnoreCase("playername") || v.getName().equalsIgnoreCase("player"))
            Bukkit.getLogger().warning("Redundancy suspected. No need to store playernames - use NameUUIDUtil instead");
    }

    public boolean existsValue(String valuename) {
        return this.values.containsKey(valuename.toLowerCase());
    }

    /**
     * Resets all stats for a Player
     *
     * @param uuid  uuid of the player
     */
    public void reset(UUID uuid) {
        StringBuilder qry = new StringBuilder("UPDATE " + worktable + " SET ");
        boolean b = false;
        for (Value v : getValues().values()) {
            if (b)
                qry.append(", ");
            else
                b = true;
            Object nullValue = getNullValue(v.getName());
            qry.append(v.getName()).append("=").append(nullValue == null ? "''" : nullValue);
        }
        mysql.update(qry + ";");
    }

    public Object getObject(String valuename, UUID playerUUID) {
        String vntlc = valuename.toLowerCase();
        if (existsValue(vntlc) && playerUUID != null) {
            try {
                ResultSet rs = mysql.query("SELECT " + vntlc + " FROM " + this.worktable + " WHERE uuid='" + playerUUID.toString() + "';");
                if (rs != null && rs.next())
                    return rs.getObject(vntlc);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return getNullValue(valuename);
    }

    public String getString(String valuename, UUID uuid) {
        return getObject(valuename, uuid).toString();
    }

    public int getInt(String valuename, UUID uuid) {
        try {
            return Integer.parseInt(getObject(valuename, uuid).toString());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
        return 0;
    }

    public double getDouble(String valuename, UUID uuid) {
        try {
            return Double.parseDouble(getObject(valuename, uuid).toString());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
        return 0;
    }

    public long getLong(String valuename, UUID uuid) {
        try {
            return Long.parseLong(getObject(valuename, uuid).toString());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
        return 0;
    }

    public boolean getBoolean(String valuename, UUID uuid) {
        Object o = getObject(valuename, uuid);
        return (boolean) o;
    }

    public int getCoins(UUID uuid) {
        return CoinsHelper.getCoins(uuid);
    }

    public void getCoinsAsynchronously(UUID uuid, Consumer<Integer> consumer) {
        CoinsHelper.getCoinsAsynchronously(uuid, consumer);
    }

    public int getRankByPoints(UUID uuid) {
        if (existsValue("points"))
            try {
                ResultSet rs = mysql.query("SELECT (SELECT COUNT(*) FROM " + worktable + " WHERE points > wt.points) + 1 AS rank FROM " + worktable + " wt WHERE uuid='" + uuid.toString() + "';");
                if (rs != null && rs.next())
                    return rs.getInt("rank");
            } catch (SQLException e) {
                e.printStackTrace();
            }
        return 0;
    }

    private Object getNullValue(String valuename) {
        if (existsValue(valuename.toLowerCase()))
            switch (values.get(valuename.toLowerCase()).getValueType()) {
                case DOUBLE:
                case INT:
                case LONG:
                case BOOLEAN:
                    return 0;
                case TIMESTAMP:
                    return -1;
                case BLOB:
                case DATE:
                case STRING:
                case VARCHAR:
                    return null;
            }
        return null;
    }

    public void increaseBy(String intValuename, UUID playerUUID, int n) {
        if (StatsAPI.getApi().getSaveStats())
            if (existsValue(intValuename))
                if (n != 0)
                    mysql.update("UPDATE " + worktable + " SET " + intValuename.toLowerCase() + "=" + intValuename.toLowerCase() + "+" + n + " WHERE uuid='" + playerUUID.toString() + "';");
    }

    public void set(String valuename, UUID playerUUID, Object value) {
        if (StatsAPI.getApi().getSaveStats())
            if (existsValue(valuename.toLowerCase()) && NameUUIDUtil.exists(playerUUID))
                mysql.update("UPDATE " + worktable + " SET " + valuename.toLowerCase() + "=" + (value == null ? values.get(valuename.toLowerCase()).getValueType().getDefaultValue() : value.toString())
                        + " WHERE uuid='" + playerUUID.toString() + "';");
    }

    public void setCoins(UUID uuid, int coins) {
        CoinsHelper.setCoins(uuid, coins);
    }

    public void addCoins(UUID uuid, int coinsToAdd) {
        CoinsHelper.addCoins(uuid, coinsToAdd);
    }

    public boolean hasCoins(UUID uuid, int coins) {
        return CoinsHelper.getCoins(uuid) >= coins;
    }

    public String getWorktable() {
        return this.worktable;
    }

    public HashMap<String, Value> getValues() {
        return this.values;
    }
}

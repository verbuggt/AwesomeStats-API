package net.exploit.statsapi.stats;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.UUID;

import org.bukkit.Bukkit;

import net.exploit.statsapi.main.StatsAPI;
import net.exploit.statsapi.mysql.MySQL;
import net.exploit.statsapi.user.NameCacheUtil;

public class StatsHelper {

	public static StatsHelper statsHelper;

	private MySQL mysql;
	private String worktable;
	private HashMap<String, Value> values = new HashMap<>();

	public StatsHelper(String table, Value[] values, boolean autoPoints) {
		StatsHelper.statsHelper = this;
		this.mysql = StatsAPI.getApi().getMySQL();
		this.worktable = table.toLowerCase();

		Bukkit.getPluginManager().registerEvents(new StatsLoginListener(statsHelper), StatsAPI.getApi());

		if (autoPoints) {
			Value[] tempValues = new Value[values.length + 1];
			System.arraycopy(values, 0, tempValues, 0, values.length);
			tempValues[values.length] = new Value("points", VT.INT);
			values = tempValues;
		}

		int l = values.length;
		boolean alter = mysql.tableExist(worktable);
		boolean execute = alter ? false : true;
		HashMap<String, String> columns_delete = alter ? mysql.getTableColumns(worktable) : null;
		String query = alter ? "ALTER TABLE " + worktable + " " : "CREATE TABLE IF NOT EXISTS " + worktable + "(uuid VARCHAR(36), ";

		for (int i = 0; i < l; i++) {
			Value v = values[i];
			String valueName = v.getName();
			try {
				validateValue(v);
			} catch (Exception e) {
				e.printStackTrace();
				break;
			}
			this.values.put(valueName, v);
			if (alter)
				if (!columns_delete.keySet().contains(valueName)) {
					if (execute)
						query += ", ";
					query += "ADD " + valueName + " " + v.getSQLString();
					execute = true;
				} else {
					if (!v.getDataTypeName().equals(columns_delete.get(v.getName()))) {
						System.out.println(columns_delete.get(v.getName()));
						System.out.println(v.getDataTypeName());
						if (execute)
							query += ", ";
						query += "MODIFY " + v.getName() + " " + v.getSQLString();
						execute = true;
					}
					columns_delete.remove(v.getName());
				}
			else {
				query += valueName + " " + v.getSQLString();
				if (i < l - 1)
					query += ", ";
				else if (i == l - 1)
					query += ", FOREIGN KEY (uuid) REFERENCES users(uuid));";
			}
		}
		if (alter)
			if (columns_delete.size() != 0) {
				for (String s : columns_delete.keySet()) {
					if (!s.equals("uuid")) {
						query += execute ? ", DROP " + s : "DROP " + s;
						execute = true;
					}
				}
				query += ";";
			}

		// Hello. Im a debug print
		// System.out.println("\nEXECUTE QUEREY: " + execute + "\nQUERY: \n" + query);
		if (execute)
			mysql.updateSynchronously(query);
	}

	public StatsHelper(String table, Value[] values) {
		this(table, values, false);
	}

	private void validateValue(Value v) throws Exception {
		if (this.values.keySet().contains(v.getName()))
			throw new Exception("Illegal Value Parameters: Duplicate Entry");
		else if (v.getName() == "uuid")
			throw new Exception("Illegal Value Parameters: Forbidden Valuename");
		else if (v.getName() == "name" || v.getName() == "playername" || v.getName() == "pname")
			Bukkit.getLogger().warning("Redundancy suspected. No need to store playernames - use UserUtil instead (<StatsHelper>.getUserUtil()) or ask verbuqqt c:");
	}

	public boolean existsValue(String valuename) {
		if (this.values.containsKey(valuename.toLowerCase()))
			return true;
		return false;
	}

	// TODO (maybe): Add Type-specific methods (getInt, getString etc.)
	public Object get(String valuename, UUID playerUUID) {
		String vntlc = valuename.toLowerCase();
		if (existsValue(vntlc) && playerUUID != null) {
			Object o = null;
			try {
				ResultSet rs = mysql.query("SELECT " + vntlc + " FROM " + this.worktable + " WHERE uuid='" + playerUUID.toString() + "';");
				if (rs.next())
					o = rs.getObject(vntlc);
			} catch (SQLException e) {
				e.printStackTrace();
			}
			return o;
		}
		return getNullValue(valuename);
	}

	private Object getNullValue(String valuename) {
		if (existsValue(valuename.toLowerCase()))
			switch (values.get(valuename.toLowerCase()).getValueType()) {
			case DOUBLE:
			case INT:
			case LONG:
			case BOOLEAN:
				return 0;
			case TIMESTAMP:
				return -1;
			case BLOB:
			case DATE:
			case STRING:
			case VARCHAR:
				return null;
			}
		return null;
	}

	public void set(String valuename, UUID playerUUID, Object value) {
		if (existsValue(valuename.toLowerCase()) && NameCacheUtil.exists(playerUUID))
			mysql.update("UPDATE " + worktable + " SET " + valuename.toLowerCase() + "=" + (value == null ? values.get(valuename.toLowerCase()).getValueType().getDefaultValue() : value.toString())
					+ " WHERE uuid='" + playerUUID.toString() + "';");
	}

	public int getCoins(UUID uuid) {
		int coins = -1;
		if (uuid != null)
			try {
				ResultSet rs = mysql.query("SELECT coins FROM coins WHERE uuid='" + uuid.toString() + "';");
				if (rs.next())
					coins = rs.getInt("coins");
			} catch (SQLException e) {
				e.printStackTrace();
			}
		return coins;
	}

	public void setCoins(UUID uuid, int coins) {
		if (uuid != null)
			mysql.update("UPDATE coins SET coins=" + coins + " WHERE uuid='" + uuid.toString() + "';");
	}

	public String getWorktable() {
		return this.worktable;
	}

	public HashMap<String, Value> getValues() {
		return this.values;
	}
}
